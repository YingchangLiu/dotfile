#!/bin/zsh
zmodload -F zsh/zpty b:zpty
zmodload -F zsh/parameter p:funcstack p:functions p:parameters
zmodload -F zsh/system b:sysopen p:sysparams
zmodload -F zsh/zselect b:zselect
zmodload -F zsh/terminfo b:echoti p:terminfo
zmodload -F zsh/zutil b:zparseopts
builtin autoload -Uz add-zle-hook-widget

typeset -gHi _autocomplete__buffer_start_line=1
typeset -g ZSH_AUTOSUGGEST_USE_ASYNC=yes

builtin zle -N history-incremental-search-backward .autocomplete.async.history-incremental-search
builtin zle -N history-incremental-search-forward .autocomplete.async.history-incremental-search

.autocomplete.async.precmd() {
  emulate -L zsh -o NO_aliases
  setopt $_autocomplete__options

  typeset -gHF _autocomplete__async_avg_duration=
  builtin zstyle -s :autocomplete: min-delay _autocomplete__async_avg_duration
  (( _autocomplete__async_avg_duration += 0.1 ))

  # Start names with `.` to avoid getting wrapped by syntax highlighting.
  builtin zle -N .autocomplete.async.pty.zle-widget
  builtin zle -C .autocomplete.async.pty.completion-widget list-choices \
      .autocomplete.async.pty.completion-widget
  builtin zle -N .autocomplete.async.complete.fd-widget
  builtin zle -C ._list_choices list-choices .autocomplete.async.list-choices.completion-widget

  if [[ -v functions[_zsh_highlight_call_widget] ]]; then
    _zsh_highlight_call_widget() {
      .autocomplete.zle-flags $WIDGET
      builtin zle "$@"
    }
  fi

  if [[ -v functions[_zsh_autosuggest_highlight_apply] ]]; then
    private action=
    for action in clear modify fetch accept partial_accept execute enable disable toggle; do
      # Set flags according to widget name.
      eval "_zsh_autosuggest_widget_$action() {
        .autocomplete.zle-flags \$WIDGET
        _zsh_autosuggest_$action \"\$@\"
      }"
    done
    _zsh_autosuggest_widget_suggest() {
      .autocomplete.zle-flags  # Maintain previously set flags.
      _zsh_autosuggest_suggest "$@"
    }
  fi

  add-zle-hook-widget line-init .autocomplete.async.read-cursor-position
  add-zle-hook-widget line-init .autocomplete.async.reset-context
  add-zle-hook-widget line-init .autocomplete.async.complete

  add-zle-hook-widget line-pre-redraw .autocomplete.async.complete
  add-zle-hook-widget line-finish .autocomplete.async.clear
  add-zle-hook-widget isearch-update .autocomplete.async.isearch-update
  add-zle-hook-widget isearch-exit .autocomplete.async.isearch-exit

  add-zsh-hook zshexit .autocomplete.async.stop
}

.autocomplete.async.read-cursor-position() {
  emulate -L zsh
  setopt $_autocomplete__options[@]

  (( KEYS_QUEUED_COUNT || PENDING )) &&
      return

  if ! [[ -v terminfo[u6] && -v terminfo[u7] ]]; then
    local -i max_lines=
    builtin zstyle -s ":autocomplete:${curcontext}:" list-lines max_lines ||
        max_lines=16
    _autocomplete__buffer_start_line=$(( min( max( LINES - max_lines, 1 ), LINES ) ))
    return 0
  fi

  # Don't run if we're in the subshell started by Midnight Commander.
  # See https://github.com/marlonrichert/zsh-autocomplete/issues/269
  [[ -v MC_SID ]] &&
      return

  # Cursor position report (u6) always contains two %d markers.
  private -a CPR=( "${(s:%d:)$( echoti u6 )}" )

  # If there is a %i before the first %d, then decrement both %d values by 1.
  private -i i=${${${(M)CPR[1]%'%i'}:+1}:-0}
  CPR[1]=${CPR[1]%'%i'}

  local REPLY=
  private Y=
  echoti u7           # Send cursor position request.

  # Parse the cursor position report.
  read -rsk $#CPR[1]  # Discard the preamble.
  while [[ $REPLY != $CPR[2] ]]; do
    read -rsk
    Y+=$REPLY
  done
  Y="${Y%$CPR[2]}"    # Discard the separator.

  # Flush the rest.
  while [[ $REPLY != $CPR[3] ]]; do
    read -rsk
  done

  _autocomplete__buffer_start_line=$(( min( max( Y - i, 1 ), LINES ) ))
}

.autocomplete.async.history-incremental-search() {
  if [[ $curcontext == $WIDGET* ]]; then
    unset curcontext
  else
    typeset -gH curcontext=${WIDGET}:::
  fi
  [[ -o sharehistory ]] &&
      fc -RI  # Get new history events from file.
  .autocomplete.async.start
}

.autocomplete.async.reset-context() {
  typeset -gH curcontext=''
  builtin zstyle -s :autocomplete: default-context curcontext
  return 0
}

.autocomplete.async.isearch-update() {
  typeset -gHi _autocomplete__isearch=1
}

.autocomplete.async.isearch-exit() {
  .autocomplete.zle-flags $LASTWIDGET
  unset _autocomplete__isearch
}

.autocomplete.async.complete() {
  .autocomplete.zle-flags $LASTWIDGET

  (( KEYS_QUEUED_COUNT || PENDING )) &&
      return

  region_highlight=()
  [[ -v functions[_zsh_highlight] ]] &&
      _zsh_highlight
  typeset -gH _autocomplete__highlight=( $region_highlight[@] )
  [[ -v functions[_zsh_autosuggest_highlight_apply] ]] &&
      _zsh_autosuggest_highlight_apply

  [[ $LASTWIDGET == .autocomplete.async.complete.fd-widget ]] &&
      return

  if (( REGION_ACTIVE )) ||
      [[ -v _autocomplete__isearch && $LASTWIDGET == *(incremental|isearch)* ]]; then
    builtin zle -Rc
    return 0
  fi

  [[ $LASTWIDGET ==
        (_complete_help|list-expand|(|.)(describe-key-briefly|what-cursor-position|where-is)) ]] &&
      return

  [[ $_lastcomp[insert] == *unambiguous ]] &&
      builtin zle .auto-suffix-retain  # Make the cursor stay in the right place.

  .autocomplete.async.start
  return 0
}

.autocomplete.async.clear() {
  builtin zle -Rc
  unset _autocomplete__isearch
  .autocomplete.async.stop
  .autocomplete.async.reset-context
  return 0
}

.autocomplete.async.stop() {
  local fd=$_autocomplete__async_complete_fd
  unset _autocomplete__async_complete_fd
  if [[ $fd == <-> ]]; then
    builtin zle -F $fd 2> /dev/null
    exec {fd}<&-
  fi
}

.autocomplete.async.start() {
  setopt $_autocomplete__options[@]
  [[ -n $curcontext ]] &&
      setopt completeinword

  typeset -gH _autocomplete__async_complete_fd=
  sysopen -r -o cloexec -u _autocomplete__async_complete_fd <(
    typeset -F SECONDS=0
    local +h PS4=$_autocomplete__ps4
    setopt promptsubst
    () {
      {
        PS1= RPS1=

        private hooks=( chpwd periodic precmd preexec zshaddhistory zshexit )
        builtin unset ${^hooks}_functions &> /dev/null
        $hooks[@] () { : }

        private hook=
        for hook in isearch-exit isearch-update line-pre-redraw line-init line-finish \
            history-line-set keymap-select; do
          builtin zle -N zle-$hook .autocomplete.async.pty.no-op
        done

        {
          local REPLY=
          zpty AUTOCOMPLETE .autocomplete.async.pty
          private -i fd=$REPLY

          zpty -w AUTOCOMPLETE $'\t'

          local header=
          zpty -r AUTOCOMPLETE header $'*\C-B'

          local -F min_delay=
          builtin zstyle -s :autocomplete: min-delay min_delay ||
              min_delay=0.0
          zselect -t "$(( [#10] 100 * max( 0, min_delay - SECONDS ) ))"

          local text=
          zselect -rt "$((
              [#10] 100 * max( 0, 10 * _autocomplete__async_avg_duration - SECONDS )
          ))" "$fd" &&
              zpty -r AUTOCOMPLETE text $'*\C-C'
        } always {
          zpty -d AUTOCOMPLETE
        }
      } always {
        # Always produce output, so we always reach the callback, so we can close the fd and unset
        # $_autocomplete__async_complete_fd (if necessary).
        print -rNC1 -- "$SECONDS" "${text%$'\C-C'}"
      }
    } "$@" 2>>| $_autocomplete__log_file
  )
  builtin zle -Fw "$_autocomplete__async_complete_fd" .autocomplete.async.complete.fd-widget

  # There's a weird bug in Zsh < 5.8, where ^C stops working unless we force a fork.
  # See https://github.com/zsh-users/zsh-autosuggestions/issues/364
  command true
}

.autocomplete.async.pty() {
  () {
    typeset -gH _znap__lbuffer="$LBUFFER" _znap__rbuffer="$RBUFFER"

    builtin bindkey $'\t' .autocomplete.async.pty.zle-widget
    local __tmp__=
    builtin vared __tmp__
  } "$@" 2>>| $_autocomplete__log_file
}

.autocomplete.async.pty.no-op() {
  :
}

.autocomplete.async.pty.zle-widget() {
  # The completion widget sometimes returns without calling its function. So, we need to print all
  # our control characters here, to ensure we don't end up waiting endlessly to read them.
  {
    print -n -- '\C-B'
    LBUFFER=$_znap__lbuffer
    RBUFFER=$_znap__rbuffer
    builtin zle .autocomplete.async.pty.completion-widget -w 2> /dev/null
  } always {
    print -n -- '\C-C'
    builtin kill $sysparams[pid]
  }
}

.autocomplete.async.pty.completion-widget() {
  () {
    local curcontext=${curcontext:-${WIDGET}:::}
    unset 'compstate[vared]'
    local +h -a comppostfuncs=( .autocomplete.async.pty.message )
    .autocomplete.async.list-choices.main-complete
    print -rNC1 -- "$compstate[nmatches]" "$_znap__message"
  } "$@" 2>>| $_autocomplete__log_file
}

.autocomplete.async.pty.message() {
  typeset -gHi _znap__message=${${_comp_mesg:-$mesg}:+1}
  return 0
}

.autocomplete.async.complete.fd-widget() {
  setopt $_autocomplete__options[@]
  [[ -n $curcontext ]] &&
      setopt completeinword NO_aliases

  local -i fd=$1
  {
    builtin zle -F $fd # Unhook ourselves immediately, so we don't get called more than once.

    # Ensure our input will not be stopped.
    unset _autocomplete__async_complete_fd

    .autocomplete.zle-flags ||
        return 0

    local seconds nmatches message rest
    IFS=$'\0' read -ru $fd seconds nmatches message rest
  } always {
    exec {fd}<&-
  }

  [[ $seconds == <->.<-> ]] ||
      return 0

  (( _autocomplete__async_avg_duration = .1 * seconds + .9 * _autocomplete__async_avg_duration ))

  # If a widget can't be called, zle always returns true.
  # Thus, we return false on purpose, so we can check if our widget got called.
  if ! builtin zle ._list_choices -w "$nmatches" "$message" 2> /dev/null; then
    region_highlight=( "$_autocomplete__highlight[@]" )
    [[ -v functions[_zsh_autosuggest_highlight_apply] ]] &&
        _zsh_autosuggest_highlight_apply

    # Refresh if and only if our widget got called. Otherwise, Zsh will crash (eventually).
    builtin zle -R
  else
    .autocomplete.async.stop
  fi
  return 0
}

.autocomplete.async.list-choices.completion-widget() {
  local +h PS4=$_autocomplete__ps4
  setopt localoptions promptsubst
  () {
    private -i nmatches=$1 message=$2

    local min_input=
    builtin zstyle -s :autocomplete: min-input min_input ||
        min_input=0

    local ignored=
    builtin zstyle -s :autocomplete: ignored-input ignored

    local +h -a comppostfuncs=( .autocomplete.async.list-choices.post "$comppostfuncs[@]" )
    if [[ -n $curcontext ]]; then
      _main_complete
    elif (( ${#words[@]} == 1 && ${#words[CURRENT]} < min_input )) ||
        [[ -n $words[CURRENT] && $words[CURRENT] == $~ignored ]]; then
      builtin zle -Rc
    elif (( nmatches || message )); then
      local curcontext=list-choices:::
      .autocomplete.async.list-choices.main-complete
    else
      builtin zle -Rc
    fi
  } "$@" 2>>| $_autocomplete__log_file

  return 2  # Don't return 1, to prevent beeping.
}

.autocomplete.async.list-choices.post() {
  [[ -v _autocomplete__partial_list ]] &&
      compadd -J -last- -x '%F{0}%K{14}(MORE)%f%k'
  compstate[insert]=
  unset MENUSELECT MENUMODE
}

.autocomplete.async.list-choices.main-complete() {
  local -i _znap__max_lines=
  () {
    local -i min_lines=
    builtin zstyle -s ":autocomplete:${curcontext}:" list-lines min_lines ||
        min_lines=16

    private -i lines_below_buffer=$(( LINES - ( _autocomplete__buffer_start_line + BUFFERLINES ) ))
    min_lines=$(( min( LINES - ( 1 + BUFFERLINES ), min_lines ) ))
    _znap__max_lines=$(( max( min_lines, lines_below_buffer ) ))
  }

  {
    [[ $curcontext == list-choices:* ]] &&
        () {
          emulate -L zsh
          setopt $_autocomplete__options[@]
          functions[compadd]=$functions[.autocomplete.async.compadd]
        } "$@"
    _main_complete
  } always {
    unfunction compadd comptags 2> /dev/null
  }
}

.autocomplete.async.compadd() {
  local -A _opts_=()
  local -aU _dopt_=()
  zparseopts -A _opts_ -E -- D: E: J: V: x: X: d:=_dopt_

  if [[ -v _opts_[-E] ]]; then
    .autocomplete.compadd "$@"
    return
  fi

  local -a _matches_=()
  private -i _ret_=1 _new_nmatches_= _new_list_lines_=
  private -i _avail_list_lines_=$((
      max( _znap__max_lines - ${${_opts_[(i)-[Xx]]}:+1} - compstate[list_lines], 0 )
  ))
  private _array_name_=

  if [[ -v _opts_[-D] ]]; then
    .autocomplete.compadd "$@"
    _ret_=$?

    [[ $funcstack[2] == _describe ]] ||
        return _ret_

    _array_name_=$_opts_[-D]
    _matches_=( ${(PA)_array_name_} )

    (( ${_matches_[(I)*:*]} > 0 )) ||
        return _ret_

    private -aU _uniques_=( ${_matches_[@]#*:} )
    _new_nmatches_=$#_matches_[@]
    _new_list_lines_=$#_uniques_[@]
    (( _avail_list_lines_ -= _autocomplete__reserved_lines ))
  else
    _autocomplete__reserved_lines=0

    # Filter out non-matching completions.
    (( ${#_dopt_[@]} )) &&
        _dopt_=( -O "$_dopt_[2]" )
    .autocomplete.compadd -O _matches_ $_dopt_ "$@"

    # Pre-emptively trim the matches that will definitely not _fit_ on screen.
    shift -p $(( max( ${#_matches_[@]} - ( ( COLUMNS * _znap__max_lines ) / 3 ), 0 ) )) _matches_

    # Note: Can't put comments inside expansions, without setting INTERACTIVE_COMMENTS.
    private -a _out_=( "${(0)"$(
      {
        trap '' SEGV
        _autocomplete.compadd_opts_len "$@"
        .autocomplete.compadd "$@[1,?]" -a -- _matches_
      } always {
        print -rNC1 -- "$compstate[list_lines]" "$compstate[nmatches]"
      }
    )"}" )
    _new_list_lines_=$(( _out_[1] - compstate[list_lines] ))
    _new_nmatches_=$((   _out_[2] - compstate[nmatches]   ))
  fi

  if (( _new_list_lines_ <= _avail_list_lines_ )); then
    if [[ $funcstack[2] == _describe && -v _opts_[-D] ]]; then
      (( _autocomplete__reserved_lines += $_new_list_lines_ ))
      return _ret_
    fi
    .autocomplete.compadd "$@"
    return
  fi

  if [[ -v _opts_[-D] ]]; then
    if (( ${#_uniques_[@]} > _avail_list_lines_ )); then
      typeset -gH _autocomplete__partial_list
      shift -p $(( ${#_uniques_[@]} - max( _avail_list_lines_ - 1, 0 ) )) _uniques_
      set -A $_array_name_ ${(M@)${(PA)_array_name_}:#*:(${(~j:|:)_uniques_})}
    fi
    (( _autocomplete__reserved_lines += ${#_uniques_[@]} ))
    (( ${(P@)#_array_name_} > 0 ))
    return
  fi

  local -a _groupname_=()
  zparseopts -A _opts_ -D -E - a k U d:=_dopt_ l=_dopt_ J:=_groupname_ V:=_groupname_
  set -- "$_groupname_[@]" "$@"

  if (( _new_list_lines_ > 0 )); then
    private -i _matches_per_line_=$(( 1.0 * _new_nmatches_ / _new_list_lines_ ))
    if (( _matches_per_line_ < 1 )); then
      _matches_per_line_=1
      if ! (( ${#_dopt_[@]} )); then
        local -a displ=( "$_matches_[@]" )
        _dopt_=( -d displ )
      fi
      _array_name_=$_dopt_[-1]
      _dopt_=( -l "$_dopt_[@]" )
      set -A $_array_name_ ${(r:COLUMNS-1:@)${(P@)_array_name_}//$'\n'/\n}
    fi
    if (( ${#_matches_[@]} > _matches_per_line_ * _avail_list_lines_ )); then
      [[ -z $_autocomplete__partial_list ]] &&
          typeset -gH _autocomplete__partial_list=$curtag

      # Round this down, before subtracting.
      private -i _fit_=$(( _matches_per_line_ * max( _avail_list_lines_ - 1, 0 ) ))

      shift -p $(( ${#_matches_[@]} - _fit_ )) _matches_
      (( ${#_matches_} > 0 )) ||
          comptags() {
            [[ $funcstack[3] == _autocomplete.history_lines ]] ||
                return 1
            builtin comptags "$@"
          }
    fi
  fi
  _autocomplete.compadd_opts_len "$@"
  .autocomplete.compadd "$@[1,?]" $_dopt_ -a -- _matches_
}
