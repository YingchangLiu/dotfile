#!/bin/zsh
zmodload -F zsh/zpty b:zpty
zmodload -F zsh/parameter p:funcstack p:functions p:parameters
zmodload -F zsh/system b:sysopen p:sysparams
zmodload -F zsh/zselect b:zselect
zmodload -F zsh/terminfo b:echoti p:terminfo
zmodload -F zsh/zutil b:zparseopts
builtin autoload -Uz add-zle-hook-widget

typeset -gHi _autocomplete__buffer_start_line=1
typeset -g ZSH_AUTOSUGGEST_USE_ASYNC=yes

builtin zle -N history-incremental-search-backward .autocomplete.async.history-incremental-search
builtin zle -N history-incremental-search-forward .autocomplete.async.history-incremental-search

.autocomplete.async.precmd() {
  emulate -L zsh -o NO_aliases
  setopt $_autocomplete__options

  typeset -gHF _autocomplete__async_avg_duration=
  builtin zstyle -s :autocomplete: min-delay _autocomplete__async_avg_duration
  (( _autocomplete__async_avg_duration += 0.1 ))

  # Start names with `.` to avoid getting wrapped by syntax highlighting.
  builtin zle -N .autocomplete.async.pty.zle-widget
  builtin zle -C .autocomplete.async.pty.completion-widget list-choices \
      .autocomplete.async.pty.completion-widget
  builtin zle -N .autocomplete.async.complete.fd-widget
  builtin zle -C ._list_choices list-choices .autocomplete.async.list-choices.completion-widget

  if [[ -v functions[_zsh_highlight_call_widget] ]]; then
    _zsh_highlight_call_widget() {
      .autocomplete.zle-flags $WIDGET
      builtin zle "$@"
    }
  fi

  if [[ -v functions[_zsh_autosuggest_highlight_apply] ]]; then
    private action=
    for action in clear modify fetch accept partial_accept execute enable disable toggle; do
      # Set flags according to widget name.
      eval "_zsh_autosuggest_widget_$action() {
        .autocomplete.zle-flags \$WIDGET
        _zsh_autosuggest_$action \"\$@\"
      }"
    done
    _zsh_autosuggest_widget_suggest() {
      .autocomplete.zle-flags  # Maintain previously set flags.
      _zsh_autosuggest_suggest "$@"
    }
  fi

  .autocomplete.patch _message

  add-zle-hook-widget line-init .autocomplete.async.read-cursor-position
  add-zle-hook-widget line-init .autocomplete.async.reset-context
  add-zle-hook-widget line-init .autocomplete.async.complete

  add-zle-hook-widget line-pre-redraw .autocomplete.async.complete
  add-zle-hook-widget line-finish .autocomplete.async.clear
  add-zle-hook-widget isearch-update .autocomplete.async.isearch-update
  add-zle-hook-widget isearch-exit .autocomplete.async.isearch-exit

  add-zsh-hook zshexit .autocomplete.async.stop
}

.autocomplete.async.read-cursor-position() {
  emulate -L zsh
  setopt $_autocomplete__options[@]

  (( KEYS_QUEUED_COUNT || PENDING )) &&
      return

  if ! [[ -v terminfo[u6] && -v terminfo[u7] ]]; then
    local -i max_lines=
    builtin zstyle -s ":autocomplete:${curcontext}:" list-lines max_lines ||
        max_lines=16
    _autocomplete__buffer_start_line=$(( min( max( LINES - max_lines, 1 ), LINES ) ))
    return 0
  fi

  # Don't run if we're in the subshell started by Midnight Commander.
  # See https://github.com/marlonrichert/zsh-autocomplete/issues/269
  [[ -v MC_SID ]] &&
      return

  # Cursor position report (u6) always contains two %d markers.
  private -a CPR=( "${(s:%d:)$( echoti u6 )}" )

  # If there is a %i before the first %d, then decrement both %d values by 1.
  private -i i=${${${(M)CPR[1]%'%i'}:+1}:-0}
  CPR[1]=${CPR[1]%'%i'}

  local REPLY=
  private Y=
  echoti u7           # Send cursor position request.

  # Parse the cursor position report.
  read -rsk $#CPR[1]  # Discard the preamble.
  while [[ $REPLY != $CPR[2] ]]; do
    read -rsk
    Y+=$REPLY
  done
  Y="${Y%$CPR[2]}"    # Discard the separator.

  # Flush the rest.
  while [[ $REPLY != $CPR[3] ]]; do
    read -rsk
  done

  _autocomplete__buffer_start_line=$(( min( max( Y - i, 1 ), LINES ) ))
} 2>>| $_autocomplete__log_file

.autocomplete.async.history-incremental-search() {
  if [[ $curcontext == $WIDGET* ]]; then
    unset curcontext
  else
    typeset -gH curcontext=${WIDGET}:::
  fi
  [[ -o sharehistory ]] &&
      fc -RI  # Get new history events from file.
  .autocomplete.async.start
}

.autocomplete.async.reset-context() {
  typeset -gH curcontext=''
  builtin zstyle -s :autocomplete: default-context curcontext
  return 0
}

.autocomplete.async.isearch-update() {
  typeset -gHi _autocomplete__isearch=1
}

.autocomplete.async.isearch-exit() {
  .autocomplete.zle-flags $LASTWIDGET
  unset _autocomplete__isearch
}

.autocomplete.async.complete() {
  .autocomplete.zle-flags $LASTWIDGET

  (( KEYS_QUEUED_COUNT || PENDING )) &&
      return

  region_highlight=()
  [[ -v functions[_zsh_highlight] ]] &&
      _zsh_highlight
  typeset -gH _autocomplete__highlight=( $region_highlight[@] )
  [[ -v functions[_zsh_autosuggest_highlight_apply] ]] &&
      _zsh_autosuggest_highlight_apply

  [[ $LASTWIDGET == .autocomplete.async.complete.fd-widget ]] &&
      return

  .autocomplete.async.stop

  if (( REGION_ACTIVE )) ||
      [[ -v _autocomplete__isearch && $LASTWIDGET == *(incremental|isearch)* ]]; then
    builtin zle -Rc
    return 0
  fi

  [[ $LASTWIDGET ==
        (_complete_help|list-expand|(|.)(describe-key-briefly|what-cursor-position|where-is)) ]] &&
      return

  [[ $_lastcomp[insert] == *unambiguous ]] &&
      builtin zle .auto-suffix-retain  # Make the cursor stay in the right place.

  .autocomplete.async.start
  return 0
}

.autocomplete.async.clear() {
  builtin zle -Rc
  unset _autocomplete__isearch
  .autocomplete.async.stop
  .autocomplete.async.reset-context
  return 0
}

.autocomplete.async.stop() {
  local fd=$_autocomplete__async_complete_fd
  unset _autocomplete__async_complete_fd
  unset _autocomplete__mesg _autocomplete__comp_mesg _autocomplete__words _autocomplete__current
  if [[ $fd == <-> ]]; then
    builtin zle -F $fd 2> /dev/null
    exec {fd}<&-
  fi
}

.autocomplete.async.start() {
  typeset -gH _autocomplete__async_complete_fd=
  sysopen -r -o cloexec -u _autocomplete__async_complete_fd <(
    typeset -F SECONDS=0
    setopt promptsubst
    PS4=$_autocomplete__ps4
    .autocomplete.async.start.inner
  )
  builtin zle -Fw "$_autocomplete__async_complete_fd" .autocomplete.async.complete.fd-widget

  # There's a weird bug in Zsh < 5.8, where ^C stops working unless we force a fork.
  # See https://github.com/zsh-users/zsh-autosuggestions/issues/364
  command true
}

.autocomplete.async.start.inner() {
  {
    setopt $_autocomplete__options[@]
    PS1= RPS1=

    private hooks=( chpwd periodic precmd preexec zshaddhistory zshexit )
    builtin unset ${^hooks}_functions &> /dev/null
    $hooks[@] () { : }

    private hook=
    for hook in isearch-exit isearch-update line-pre-redraw line-init line-finish \
        history-line-set keymap-select; do
      builtin zle -N zle-$hook .autocomplete.async.pty.no-op
    done

    {
      local REPLY=
      zpty AUTOCOMPLETE .autocomplete.async.pty
      private -i fd=$REPLY

      zpty -w AUTOCOMPLETE $'\t'

      local -F min_delay=
      builtin zstyle -s :autocomplete: min-delay min_delay ||
          min_delay=0.01
      zselect -t "$(( [#10] 100 * max( 0, min_delay - SECONDS ) ))"

      local header=
      zpty -r AUTOCOMPLETE header $'*\C-B'

      local text=
      zselect -rt "$((
          [#10] 100 * max( 0, 100 * _autocomplete__async_avg_duration - SECONDS )
      ))" "$fd" &&
          zpty -r AUTOCOMPLETE text $'*\C-C'
    } always {
      zpty -d AUTOCOMPLETE
    }
  } always {
    # Always produce output, so we always reach the callback, so we can close the fd and unset
    # $_autocomplete__async_complete_fd (if necessary).
    print -rNC1 -- "$SECONDS" "${text%$'\0\C-C'}"
  }
} 2>>| $_autocomplete__log_file
# functions -T .autocomplete.async.start.inner

.autocomplete.async.pty() {
  typeset -gH _autocomplete__lbuffer="$LBUFFER" _autocomplete__rbuffer="$RBUFFER"

  builtin bindkey $'\t' .autocomplete.async.pty.zle-widget
  local __tmp__=
  builtin vared __tmp__
} 2>>| $_autocomplete__log_file

.autocomplete.async.pty.no-op() {
  :
}

.autocomplete.async.pty.zle-widget() {
  .autocomplete.async.pty.zle-widget.inner "$@"
}

.autocomplete.async.pty.zle-widget.inner() {
  # The completion widget sometimes returns without calling its function. So, we need to print all
  # our control characters here, to ensure we don't end up waiting endlessly to read them.
  {
    print -n -- '\C-B'
    LBUFFER=$_autocomplete__lbuffer
    RBUFFER=$_autocomplete__rbuffer
    setopt $_autocomplete__options[@]
    [[ -n $curcontext ]] &&
        setopt completeinword NO_aliases
    builtin zle .autocomplete.async.pty.completion-widget -w 2> /dev/null
  } always {
    print -n -- '\C-C'
    builtin kill $sysparams[pid]
  }
} 2>>| $_autocomplete__log_file
# functions -T .autocomplete.async.pty.zle-widget.inner

.autocomplete.async.pty.completion-widget() {
  .autocomplete.async.pty.completion-widget.inner "$@"
}

.autocomplete.async.pty.completion-widget.inner() {
  if .autocomplete.async.insufficient-input; then
    print -rNC1 -- "0" "" ""
    return
  fi
  if .autocomplete.async.same-state; then
    print -rNC1 -- "$_lastcomp[nmatches]" "$_autocomplete__mesg" "$_autocomplete__comp_mesg[@]"
    return
  fi
  unset _autocomplete__mesg _autocomplete__comp_mesg
  {
    local curcontext=${curcontext:-${WIDGET}:::}
    unset 'compstate[vared]'

    _message() {
      compadd() {
        typeset -gHa _autocomplete__comp_mesg=( "$@" )
        .autocomplete.compadd "$@"
      }
      zformat() {
        builtin zformat "$@"
        typeset -gHa _autocomplete__comp_mesg=( "$gopt[@]" -x "$format" )
      }
      .autocomplete._message "$@"
      unfunction zformat
      functions[compadd]="$functions[.autocomplete.compadd]"
    }

    local +h -a comppostfuncs=( .autocomplete.async.pty.message )
    _main_complete
  } always {
    print -rNC1 -- "$compstate[nmatches]" "$_autocomplete__mesg" "$_autocomplete__comp_mesg[@]"
  }
} 2>>| $_autocomplete__log_file
# functions -T .autocomplete.async.pty.completion-widget.inner

.autocomplete.async.pty.message() {
  typeset -gH _autocomplete__mesg=$mesg
  return 0
}

.autocomplete.async.complete.fd-widget() {
  setopt promptsubst
  local +h PS4=$_autocomplete__ps4
  .autocomplete.async.complete.fd-widget.inner "$@"
}

.autocomplete.async.complete.fd-widget.inner() {
  local -i fd=$1
  {
    builtin zle -F $fd # Unhook ourselves immediately, so we don't get called more than once.

    # Ensure our input will not be stopped.
    unset _autocomplete__async_complete_fd

    .autocomplete.zle-flags ||
        return 0

    local -a reply=()
    IFS=$'\0' read -rAu $fd
    shift -p reply
  } always {
    exec {fd}<&-
  }

  setopt $_autocomplete__options[@]
  [[ -n $curcontext ]] &&
      setopt completeinword NO_aliases
  unset _autocomplete__mesg _autocomplete__comp_mesg

  # If a widget can't be called, zle always returns true.
  # Thus, we return false on purpose, so we can check if our widget got called.
  if ! builtin zle ._list_choices -w "$reply[@]" 2>>| $_autocomplete__log_file; then
    region_highlight=( "$_autocomplete__highlight[@]" )
    [[ -v functions[_zsh_autosuggest_highlight_apply] ]] &&
        _zsh_autosuggest_highlight_apply

    # Refresh if and only if our widget got called. Otherwise, Zsh will crash (eventually).
    builtin zle -R
  else
    .autocomplete.async.stop
  fi
  return 0
} 2>>| $_autocomplete__log_file
# functions -T .autocomplete.async.complete.fd-widget.inner

.autocomplete.async.insufficient-input() {
  local min_input=
  builtin zstyle -s :autocomplete:${curcontext:-list-choices} min-input min_input ||
      min_input=0
  local ignored=
  builtin zstyle -s :autocomplete:${curcontext:-list-choices} ignored-input ignored
  if (( ${#words[@]} == 1 && ${#words[CURRENT]} < min_input )) ||
      [[ -n $words[CURRENT] && $words[CURRENT] == $~ignored ]]; then
    compstate[list]=
    true
  else
    false
  fi
}
# functions -T .autocomplete.async.insufficient-input

.autocomplete.async.same-state() {
  [[ $_autocomplete__words == $words && $_autocomplete__current == $CURRENT ]]
}

.autocomplete.async.list-choices.completion-widget() {
  unset _autocomplete__mesg _autocomplete__comp_mesg _autocomplete__words _autocomplete__current

  if [[ $1 != <->.<-> || $2 != <-> ]]; then
    compstate[list]=
    return
  fi

  .autocomplete.async.insufficient-input &&
      return

  private -F _seconds_=$1
  private -i _nmatches_=$2
  private _mesg_=$3
  shift 3

  if [[ -n $1 ]]; then
    compadd "$@"
  elif [[ $_nmatches_ == 0 && -n $_mesg_ ]]; then
    compadd -x "$_mesg_"
  elif [[ -n $compstate[old_list] ]] && .autocomplete.async.same-state; then
    compstate[old_list]=keep
  else
    _autocomplete__async_avg_duration=$((
        .1 * _seconds_ + .9 * _autocomplete__async_avg_duration
    ))
    local +h -a comppostfuncs=( .autocomplete.async.list-choices.post "$comppostfuncs[@]" )
    if [[ -n $curcontext ]]; then
      _main_complete
    else
      .autocomplete.async.list-choices.main-complete
    fi
  fi

  typeset -gH _autocomplete__mesg=$_mesg_
  typeset -gHa _autocomplete__comp_mesg=( "$@" )
  typeset -gHa _autocomplete__words=( "$words[@]" )
  typeset -gHi _autocomplete__current=$CURRENT

  return 2  # Don't return 1, to prevent beeping.
} 2>>| $_autocomplete__log_file
# functions -T .autocomplete.async.list-choices.completion-widget

.autocomplete.async.list-choices.post() {
  [[ -v _autocomplete__partial_list ]] &&
      compadd -J -last- -x '%F{0}%K{14}(MORE)%f%k'
  compstate[insert]=
  unset MENUSELECT MENUMODE
}

.autocomplete.async.list-choices.main-complete() {
  {
    local -i _autocomplete__max_lines=
    () {
      emulate -L zsh
      setopt $_autocomplete__options[@]

      local -i min_lines=
      builtin zstyle -s ":autocomplete:${curcontext}:" list-lines min_lines ||
          min_lines=16

      private -i lines_below_buffer=$(( LINES - ( _autocomplete__buffer_start_line + BUFFERLINES ) ))
      min_lines=$(( min( LINES - ( 1 + BUFFERLINES ), min_lines ) ))
      _autocomplete__max_lines=$(( max( min_lines, lines_below_buffer ) ))

      functions[compadd]=$functions[.autocomplete.async.compadd]
    } "$@"
    local curcontext=list-choices:::
    _main_complete
  } always {
    unfunction compadd comptags 2> /dev/null
  }
}

.autocomplete.async.compadd() {
  local -A _opts_=()
  local -aU _dopt_=()
  zparseopts -A _opts_ -E -- D: E: J: V: x: X: d:=_dopt_

  if [[ -v _opts_[-E] ]]; then
    .autocomplete.compadd "$@"
    return
  fi

  local -a _matches_=()
  private -i _ret_=1 _new_nmatches_= _new_list_lines_=
  private -i _avail_list_lines_=$((
      max( _autocomplete__max_lines - ${${_opts_[(i)-[Xx]]}:+1} - compstate[list_lines], 0 )
  ))
  private _array_name_=

  if [[ -v _opts_[-D] ]]; then
    .autocomplete.compadd "$@"
    _ret_=$?

    [[ $funcstack[2] == _describe ]] ||
        return _ret_

    _array_name_=$_opts_[-D]
    _matches_=( ${(PA)_array_name_} )

    (( ${_matches_[(I)*:*]} > 0 )) ||
        return _ret_

    private -aU _uniques_=( ${_matches_[@]#*:} )
    _new_nmatches_=$#_matches_[@]
    _new_list_lines_=$#_uniques_[@]
    (( _avail_list_lines_ -= _autocomplete__reserved_lines ))
  else
    _autocomplete__reserved_lines=0

    # Filter out non-matching completions.
    (( ${#_dopt_[@]} )) &&
        _dopt_=( -O "$_dopt_[2]" )
    .autocomplete.compadd -O _matches_ $_dopt_ "$@"

    # Pre-emptively trim the matches that will definitely not _fit_ on screen.
    shift -p $(( max( ${#_matches_[@]} - ( ( COLUMNS * _autocomplete__max_lines ) / 3 ), 0 ) )) _matches_

    # Note: Can't put comments inside expansions, without setting INTERACTIVE_COMMENTS.
    private -a _out_=( "${(0)"$(
      {
        trap '' SEGV
        _autocomplete.compadd_opts_len "$@"
        .autocomplete.compadd "$@[1,?]" -a -- _matches_
      } always {
        print -rNC1 -- "$compstate[list_lines]" "$compstate[nmatches]"
      }
    )"}" )
    _new_list_lines_=$(( _out_[1] - compstate[list_lines] ))
    _new_nmatches_=$((   _out_[2] - compstate[nmatches]   ))
  fi

  if (( _new_list_lines_ <= _avail_list_lines_ )); then
    if [[ $funcstack[2] == _describe && -v _opts_[-D] ]]; then
      (( _autocomplete__reserved_lines += $_new_list_lines_ ))
      return _ret_
    fi
    .autocomplete.compadd "$@"
    return
  fi

  if [[ -v _opts_[-D] ]]; then
    if (( ${#_uniques_[@]} > _avail_list_lines_ )); then
      typeset -gH _autocomplete__partial_list
      shift -p $(( ${#_uniques_[@]} - max( _avail_list_lines_ - 1, 0 ) )) _uniques_
      set -A $_array_name_ ${(M@)${(PA)_array_name_}:#*:(${(~j:|:)_uniques_})}
    fi
    (( _autocomplete__reserved_lines += ${#_uniques_[@]} ))
    (( ${(P@)#_array_name_} > 0 ))
    return
  fi

  local -a _groupname_=()
  zparseopts -A _opts_ -D -E - a k U d:=_dopt_ l=_dopt_ J:=_groupname_ V:=_groupname_
  set -- "$_groupname_[@]" "$@"

  if (( _new_list_lines_ > 0 )); then
    private -i _matches_per_line_=$(( 1.0 * _new_nmatches_ / _new_list_lines_ ))
    if (( _matches_per_line_ < 1 )); then
      _matches_per_line_=1
      if ! (( ${#_dopt_[@]} )); then
        local -a displ=( "$_matches_[@]" )
        _dopt_=( -d displ )
      fi
      _array_name_=$_dopt_[-1]
      _dopt_=( -l "$_dopt_[@]" )
      set -A $_array_name_ ${(r:COLUMNS-1:@)${(P@)_array_name_}//$'\n'/\n}
    fi
    if (( ${#_matches_[@]} > _matches_per_line_ * _avail_list_lines_ )); then
      [[ -z $_autocomplete__partial_list ]] &&
          typeset -gH _autocomplete__partial_list=$curtag

      # Round this down, before subtracting.
      private -i _fit_=$(( _matches_per_line_ * max( _avail_list_lines_ - 1, 0 ) ))

      shift -p $(( ${#_matches_[@]} - _fit_ )) _matches_
      (( ${#_matches_} > 0 )) ||
          comptags() {
            [[ $funcstack[3] == _autocomplete.history_lines ]] ||
                return 1
            builtin comptags "$@"
          }
    fi
  fi
  _autocomplete.compadd_opts_len "$@"
  .autocomplete.compadd "$@[1,?]" $_dopt_ -a -- _matches_
}
